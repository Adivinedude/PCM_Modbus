Crash Course in Designing Networked Factory Equipment.
Best viewed in font "Courier New" size 10. 
its mono-space and there are tables.

Thank you so much for reading this. You had a choice in folks to listen to, and you
picked wrong. Down the bunny hole we go.

Modules and Units Communications Overview
1.0)
Starting off with the definition of a module within the context of this writing.
    A module is any apparatus, wither a single unit, or a network of interconnected
units, which can respond to commands and produces reply's.

The definition of a unit, 
    Any device, whether virtual or physical, that contains one or more modules.

1.1)
Each module must be able to receive a transmission, and respond appropriately.
The network byte order is defined to always be big-endian. This is the law of
machine networking. Dont care why, just know that it is. Will be on the final!

It is desirable for each module to receive and respond to a standardized set of
commands. Each unit within the network, need not be addressed, but the modules
contained within each unit should be uniquely addressed, so that they may be
commanded by a governing structure.

1.2)
Preexisting knowledge of a module unique address will be assumed, as discovery
protocols and applications are a complex topic that will not be covered today.

1.3)
Using hardware communication protocols in an industrial environment, presents a few
common problems, which have been solved by the early pioneers in the field many 
years ago. The biggest problems are corruption of transmissions and, disconnected
or failed network links.

Transmission corruption can be detected by the use of a checksum algorithm. In its
most simple form, a checksum algorithm, "Checks the Sum" of all bytes of data
within a transmission. The sender, calculates this sum and adds it to the
transmission, so the receiver can verify the data was transmitted successfully

1.4)
The problem of failed network links can be detected by sending regular request.
These request demand a prompt response from the receiver so that the reliability of
the network link can be verified.

1.5)
Message transmission time rules should be established and strictly enforced based
on the capabilities of the protocol selected.


Overall Application design considerations for a modular system.
2.0) 
It is important to point out, these principles are not limited to physical devices
spread about a space. All of these concepts equally apply to virtual devices within
a programmed architecture.

2.1) 
Communication between modules is a daunting task. Within a program, it is much
easier to simply call a function, and the task is performed. Once a project reaches
a larger level, implementing a standardized communication procedure requires the
logic of the application to be completely reorganized, often requiring massive
rewrites of code.

2.3) 
Skipping many different possible solutions to this issue and hours of hot online 
debates about software theology, designing the application using callback routines
will simultaneously incorporate, items such as multitasking, parallelism,
sequential operations and compartmentalization all in an easy to read, write and 
edit format.

2.4) 
Designing a message queue, to be accessed by a callback will emulate how GUI based
application are currently constructed for mainstream operating systems such as
Unix, mac, android and PC. Additional this technique is taught in all advanced
programming courses, with many good tutorials available

Transmission Protocol Details.
3.0)
Data formatting is the next consideration. What will a transmission look like.
By using a standard protocol and the appropriate integrated circuits, we need not
worry about the exact details of how we will transfer data from one point to
another. Additionally by using a mcu with a uart peripheral, we need not worry
about collecting the data ether. As the peripheral will tell us when a transmission
has been received.

3.1)
Now that we have a transmission, and verified the data, we have to send an
acknowledgment to the sender letting them know the data was received.

3.2) 
Design of message "phraser" to decode the data into the information needed to
perform the task requested, requires the data be sent in some logical order.
There are many well known and established industrial protocols which can be easily
included into a project using open-source library. Your project will be a much
greater success, and more profitable if it uses well known, well vetted
technologies.
As another incentive, you don't have to waste time reinventing the wheel.
I will be demonstrating the use of "ModBus over serial" in further sections.

4.0) Using as much open-source hardware and software available. Lets dig into some
abstract programming.

4.1) 
Order of operations.

1)pick hardware
2)Install Arduino IDE
3)write software
4)find problems
5)fix problems
6)Give it away for free to someone who will change the world for the better


4.2)
Hardware selection.

(4)Liquid pump - 12V DC Dosing Pump Peristaltic Dosing Head with Connector For
Arduino Aquarium Lab Analytic DIY AE1207

(2)Motor Driver - L298N Motor Driver Controller Board Module Stepper Motor DC Dual
H-Bridge for Arduino Smart Car Power

(1)Pump Control Board - Nano Board V3.0 ATmega328P

(1)Communication Module - MAX485 RS485 Transceiver Module TTL UART Serial to RS-485
Module for Arduino

4.3)
Outline Design for a Pump Control Module (PCM) functionality

The PCM will direct the motor driver to drive the motors and dispense known
volumes.
With positive feedback, a fixed number of pulses will be obtained per unit of
product dispensed. A PID theology will be implemented, so that the speed of the
dispensing will be as fast as possible without overshoot.

Without positive feedback, a less accurate time based estimation will be necessary.
 
A Calibration value will need to be obtained, so that regardless of feedback type,
we can predict how much product has been dispensed.

4.4)
Outline Design for a Pump Control Module (PCM) communications
required reading : https://www.csimn.com/CSI_pages/Modbus101.html

The PCM will be controlled as described in section 3. "ModBus over serial"
The PCM control logic will be assigned as a set of registers.
These registers will, when appropriate, allow direct control of the hardware for
debugging and troubleshooting of the device. Otherwise they will simply be a means
of telling the PCM how much fluid to dispense over a time period, As well as
reporting the progress of an operation back and overall device status to the
governing system.

4.5)
The main architecture of the PCM will be that of a "Finite state machine", for
those versed in digital/mechanical/electronic logic systems, this phrase will be
well know, for everyone else, stop here and review these text.
https://www.google.com/search?q=what+is+a+start+stop+station
https://youtu.be/pK6XN7sFosI?si=XI5xKt9VS1SJUUge - Finite State Machines

I will be demonstrating the abstract coordination of the system as if it was
constructed with Normally Open and Normally Closed logic relays to better
facilitate the use of ModBus protocols. To Start we need to define "Points" the
ModBus will use to interface with the PCM. Think of it as buttons and dials that
can be pushed and turned, and lights and readouts that give the operator
information.

Quick ModBus refresher. 
"Coil" are outputs from the controller, inputs to the device. 1bit
Example - on/off switch

"Discrete Input" are inputs to the controller, outputs from the device. 1bit
Example - Status Light

"Holding Register" are outputs from the controller, inputs to the device. 16bit
Example - Set Point Temperature

"Input Register" are inputs to the controller, outputs from the device. 16bit
Example - Present Value Temperature

The selected hardware runs 4 pumps. Addressing Each pump individually would make 
the controllers job much easier, by wasting available addresses on the ModBus data
buss. that would require editing of the open-source library in such a way that one 
unit could respond to multiple addresses. This is a lot more work that would be
required, than if the controller simply knows and command the 4 pumps through one
address. This would require duplicate points for each motor, an easy task if not
ugly and confusing.

Table 4.5.1)
address - Register Type - Function

Pump 1
0x00 - coil - Enable the device. On/Off switch
0x01 - coil - Use Positive Feedback
0x02 - coil - Enable debug/direct control of the motors via communication.
0x03 - coil - Set or invert the direction of the motor
Pump 2
0x04 - coil - Enable the device. On/Off switch
0x05 - coil - Use Positive Feedback
0x06 - coil - Enable debug/direct control of the motors via communication.
0x07 - coil - Set or invert the direction of the motor
Pump 3
0x08 - coil - Enable the device. On/Off switch
0x09 - coil - Use Positive Feedback
0x0a - coil - Enable debug/direct control of the motors via communication.
0x0b - coil - Set or invert the direction of the motor
Pump 4
0x0c - coil - Enable the device. On/Off switch
0x0d - coil - Use Positive Feedback
0x0e - coil - Enable debug/direct control of the motors via communication.
0x0f - coil - Set or invert the direction of the motor

----------

0x00 - d_input - busy  Pump 1
0x01 - d_input - error Pump 1
0x02 - d_input - busy  Pump 2
0x03 - d_input - error Pump 2
0x04 - d_input - busy  Pump 3
0x05 - d_input - error Pump 3
0x06 - d_input - busy  Pump 4
0x07 - d_input - error Pump 4


----------

Pump 1
0x00 - h_register - CALIBRATION value. "Second per Unit" or "Pulses per Unit"
0x01 - h_register - DURATION. How many seconds to dispense the dose
0x02 - h_register - DOSE. How many units to dispense
0x03 - h_register - Motor Type. see selected driver for options
Pump 2
0x04 - h_register - CALIBRATION
0x05 - h_register - DURATION
0x06 - h_register - DOSE
0x07 - h_register - Motor Type
Pump 3
0x08 - h_register - CALIBRATION
0x09 - h_register - DURATION
0x0A - h_register - DOSE
0x0B - h_register - Motor Type
Pump 4
0x0C - h_register - CALIBRATION
0x0D - h_register - DURATION
0x0E - h_register - DOSE
0x0F - h_register - Motor Type

----------

Pump 1
0x00 - i_register - TOTAL_FEEDBACK for this request
0x01 - i_register - CYCLES remaining for this request
0x02 - i_register - DOSE per cycle for this request
0x03 - i_register - TIMER_VALUE timer to track cycle duration
0x04 - i_register - TOTAL units dispensed

Pump 2
0x05 - i_register - TOTAL_FEEDBACK
0x06 - i_register - CYCLES
0x07 - i_register - DOSE
0x08 - i_register - TIMER_VALUE
0x09 - i_register - TOTAL

Pump 3
0x0a - i_register - TOTAL_FEEDBACK
0x0b - i_register - CYCLES
0x0c - i_register - DOSE
0x0d - i_register - TIMER_VALUE
0x0e - i_register - TOTAL

Pump 4
0x0f - i_register - TOTAL_FEEDBACK
0x10 - i_register - CYCLES
0x11 - i_register - DOSE
0x12 - i_register - TIMER_VALUE
0x13 - i_register - TOTAL

----------

Special Registers
0x14 - i_register - FreeRam. ammount of system memory currently available
0x15 - i_register - System Cycles per second. How fast the controller is processing

4.6)
There is an order to the madness and complete cluster $<"( of table 5.5.1. 
It is written down in stone so that it becomes a simple algebraic offset problem 
when we need to address a pumps points later.

Each data type has a fixed set size. To get the address of a coil for any pump.

True_address = ( pump# - 1 ) * set_size + point#

for example to get the address for "debug point, pump 4". 
the debug point is 0x02. 
( 0x04 - 1 ) * 4 + 0x02
( 0x03 ) * 4 + 0x02
 0x0c + 0x02
0x0E

hard for us, easy for a computer.
the set_size for each type of register are
coils - 4, d_input - 1, h_registers - 3, i_registers - 5

We will write an inline function that will be computed at compile time so this will
not fatten our final program and waste limited resources on the control board.

4.7)
The state machine will only by active when the "Enable" point is set to high.
As the state machine progresses, its progress will be stored through iteration in
status registers.

4.8)
States of operation
if "enable coil" is low, state is set to 0x00 - idle

Stage 0x00 - idle
turn off motor
The system is waiting for a command.

Stage 0x01 - Command received
Process input parameters
Setup registers for dispensing cycles
Set busy flag
Drop into the next stage

Stage 0x02 - command in progress
dispense product / turn on motor
track feedback.
update progresses
repeat this stage until finished

stage 0x03 - command finished
unset busy flag
repeat this stage indefinitely.


4.10)
After a more in-depth look at the stages, We will have a better understanding of
what is needed to actually perform the work we want with the precision we need.

0x00 - Idle Stage - Here we can do housekeeping, but for now, it's gonna set the
motor to off.

0x01 - Receive Stage - We input our command into whatever logic system needed to
satisfy the command.

0x02 - In Progress Stage - Here is where we shine and perform magic. As with any
problem, start with what we know.

We know that we want to dispense "A" number of units.
We know that based on our feedback register, ether
Feedback == false
    It takes "X" number of time intervals to dispense one unit of volume.
Feedback == true
    It takes "X" number of pulse per unit

I should point out that I have not defined our units of time or volume.
We will later define time units based on the micro controller's capabilities.
Units of volume we will not define. The true volume will be a function of the
calibration value we are given, ml gallons, kilograms, and We don't care.
Each will have its own calibration coefficient. See how I slipped mass into there.
This works for non liquids, too.

So the order of operations, for each mode, feedback, or no feedback, is
1) Calculate the stop value.
2) Configure timer
3) assign timer to Motor Enable Pin.
4) Enable the motor pin.
5) Wait for timer to expire

So after you read this, you should notice there is a problem immediately.
How fast do motors start and stop?
are we pumping more than requested?
With the feedback, it really does not matter.

we can set up 2 count cycles
The first will count at full speed to something like, total-10.
then, at a slower speed, we pump the last few pulses.


But without feedback,
we are stuck with the non-linearity of the motor vs. speed.
It will need a windup and wind down time.
I will not address this issue today.
it's a complex topic that is solved by adding feedback.

stage 0x03 - command finished.
here, we unset the busy flag to let the controller know we have finished work.
we also turn the motor off.
and we wait, leaving the system in a "locked out" state.
the only way to exit this state is to turn off the enable coil.

4.11)
Things to point out.
if the controller turns off the device before the command is complete, it is up to 
the controller to determine how much product has been dispensed. if we're nice, we
can perform one final update to the status register to include the amount dispensed
up to the point of interruption.

by now, it seems like this is over complicating a simple procedure, your correct.
by accounting for every possible situation, we can keep the amount of undefined
behavior to a minimum.
i haven't even gotten into physical limitations yet. but this is enough to get
started writing code.
remember way back in 1.2. we have to have a method to address the device. Configure
the ModBus network parameters. We will do this through the USB serial interface.

5.0)
compiling the example ino shows that 44% of the available program space and 54% of
our ram on the MCU is taken up. This means we have to be careful when adding
additional functionality.
Arduino IDE is not the best platform for this type of development, but should work
just fine.
There is 873 bytes of ram remaining.

To the code.... see you there.
sketch_PCM.ino
